import{_ as a,c as i,o as n,ae as l}from"./chunks/framework.DYx9Zc8T.js";const c=JSON.parse('{"title":"门面（Facades）","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/facades.md","filePath":"guide/architecture/facades.md"}'),e={name:"guide/architecture/facades.md"};function p(t,s,h,k,r,d){return n(),i("div",null,[...s[0]||(s[0]=[l(`<h1 id="门面-facades" tabindex="-1">门面（Facades） <a class="header-anchor" href="#门面-facades" aria-label="Permalink to &quot;门面（Facades）&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>门面（Facade）是一种让你以函数或全局变量的形式，优雅地访问容器中服务的模式。它的目标是：</p><ul><li>提供简洁、可读的调用方式</li><li>仍然保留底层的依赖注入和可测试性</li></ul><p>如果你熟悉 Laravel，那么 Goal-Web 中的门面概念会非常类似，只是实现方式更符合 Go 的语言风格。</p><h2 id="为什么需要门面" tabindex="-1">为什么需要门面 <a class="header-anchor" href="#为什么需要门面" aria-label="Permalink to &quot;为什么需要门面&quot;">​</a></h2><p>在使用服务容器时，最直接的写法通常是：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;logger&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;User logged in&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>当你在很多地方都需要记录日志时，这样的写法会显得啰嗦。通过门面，你可以将其简化为：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;User logged in&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">其中 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`logs\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 就是一个门面，它内部会从容器解析真正的 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`contracts.Logger\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 实例。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">## 一个简化示例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">下面是一个简化的日志门面示例，用于说明典型的实现思路：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\`\`go</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">var app contracts.Application</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">func SetApplication(a contracts.Application) {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    app = a</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">func Logger() contracts.Logger {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    return app.Get(&quot;logger&quot;).(contracts.Logger)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">func Info(message string, fields map[string]any) {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Logger().Info(message, fields)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span></code></pre></div><p>在应用启动时，你可以调用 <code>SetApplication</code> 将应用实例注入到门面中，之后就可以在任意地方使用 <code>Info</code> 等方法。</p><p>注意：实际框架中的门面实现会更加抽象和通用，这里仅用于帮助理解基本思路。</p><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><p>门面可以让调用代码非常简洁，但也需要注意几个实践经验：</p><ul><li>在核心业务逻辑中优先使用依赖注入，便于测试</li><li>在控制器、命令等上层代码中适度使用门面以提升可读性</li><li>不要在门面内部写业务逻辑，门面只负责转发调用</li></ul><p>一个常见的折中方案是：</p><ul><li>领域服务、仓储等核心组件通过构造函数注入依赖</li><li>日志、事件、队列等基础设施在上层可以通过门面简化调用</li></ul><h2 id="与服务容器和服务提供者的关系" tabindex="-1">与服务容器和服务提供者的关系 <a class="header-anchor" href="#与服务容器和服务提供者的关系" aria-label="Permalink to &quot;与服务容器和服务提供者的关系&quot;">​</a></h2><p>门面本身不直接创建服务实例，而是依赖：</p><ul><li>服务容器：真正保存和解析服务实例</li><li>服务提供者：在应用启动时向容器注册服务</li></ul><p>你可以将三者的关系理解为：</p><ul><li>服务提供者：定义 &quot;有哪些服务&quot;，以及如何创建它们</li><li>服务容器：负责保存和解析这些服务</li><li>门面：为这些服务提供一个更易用的调用外观</li></ul><p>掌握门面模式，有助于你在保持代码简洁的同时，不牺牲可测试性与架构清晰度。</p>`,23)])])}const g=a(e,[["render",p]]);export{c as __pageData,g as default};
