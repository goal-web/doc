import{_ as a,c as s,o as l,ae as e}from"./chunks/framework.DYx9Zc8T.js";const c=JSON.parse('{"title":"应用生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/application-lifecycle.md","filePath":"guide/architecture/application-lifecycle.md"}'),t={name:"guide/architecture/application-lifecycle.md"};function n(p,i,h,r,k,o){return l(),s("div",null,[...i[0]||(i[0]=[e(`<h1 id="应用生命周期" tabindex="-1">应用生命周期 <a class="header-anchor" href="#应用生命周期" aria-label="Permalink to &quot;应用生命周期&quot;">​</a></h1><h2 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h2><p>Goal-Web 的应用生命周期围绕 &quot;应用实例 + 服务提供者 + 请求处理&quot; 三个核心阶段展开：</p><ul><li>应用启动：创建应用实例，注册所有服务提供者</li><li>服务启动：并发启动各个基础服务（数据库、队列、HTTP 等）</li><li>请求处理：接收请求，通过路由和中间件分发到控制器</li><li>应用停止：优雅关闭服务，释放资源</li></ul><p>理解生命周期，有助于你在正确的时机注册服务、执行启动逻辑，以及安排资源释放。</p><h2 id="应用对象" tabindex="-1">应用对象 <a class="header-anchor" href="#应用对象" aria-label="Permalink to &quot;应用对象&quot;">​</a></h2><p>应用对象实现了 <code>contracts.Application</code> 接口，它本质上是一个带有服务容器能力的核心对象：</p><ul><li>嵌入 <code>Container</code>：提供依赖注入和对象解析能力</li><li>管理服务提供者：负责注册和启动各个组件</li><li>管理调试开关：决定是否输出调试日志</li></ul><p>接口定义可以在 <code>contracts/application.go</code> 中找到。</p><h2 id="启动流程" tabindex="-1">启动流程 <a class="header-anchor" href="#启动流程" aria-label="Permalink to &quot;启动流程&quot;">​</a></h2><p>典型的启动流程可以分为三个步骤：</p><ol><li>创建应用实例</li><li>注册服务提供者</li><li>启动服务并开始处理请求</li></ol><p>在你的 <code>main.go</code> 中，一般会先创建应用并注册需要的服务提供者（HTTP、数据库、队列等），然后调用 <code>Start</code>：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> application.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RegisterServices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServiceProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{},</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">database</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServiceProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{},</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServiceProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">errors </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(errors) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理启动错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="start-与-stop" tabindex="-1">Start 与 Stop <a class="header-anchor" href="#start-与-stop" aria-label="Permalink to &quot;Start 与 Stop&quot;">​</a></h2><p>应用对象内部维护了一个服务提供者列表，在 <code>Start</code> 和 <code>Stop</code> 时会按约定顺序调用它们：</p><ul><li><code>Start</code>：并发启动所有服务提供者，提高启动速度</li><li><code>Stop</code>：倒序关闭各个服务，确保依赖关系正确</li></ul><p>这意味着：</p><ul><li>先注册的服务会先启动，最后关闭</li><li>你可以在服务的 <code>Start</code> 和 <code>Stop</code> 中进行资源初始化和释放</li></ul><h2 id="请求生命周期" tabindex="-1">请求生命周期 <a class="header-anchor" href="#请求生命周期" aria-label="Permalink to &quot;请求生命周期&quot;">​</a></h2><p>当 HTTP 服务启动后，每一个进入应用的请求大致会经历以下步骤：</p><ol><li>HTTP 服务器接收请求</li><li>请求进入中间件管道，执行全局与路由中间件</li><li>路由解析 URL，找到对应的控制器或处理函数</li><li>服务容器解析控制器依赖并实例化控制器</li><li>调用控制器方法或处理函数，生成响应</li><li>响应通过中间件返回并最终发送给客户端</li></ol><p>你在 &quot;基础功能&quot; 章节中看到的路由、中间件、控制器等，都是建立在这一路径之上的。</p><h2 id="在生命周期中扩展应用" tabindex="-1">在生命周期中扩展应用 <a class="header-anchor" href="#在生命周期中扩展应用" aria-label="Permalink to &quot;在生命周期中扩展应用&quot;">​</a></h2><p>根据生命周期的不同阶段，常见的扩展方式包括：</p><ul><li>在服务提供者的 <code>Register</code> 中向容器注册绑定</li><li>在服务提供者的 <code>Start</code> 中启动后台任务或监听器</li><li>在 HTTP 服务启动后，通过中间件与路由扩展请求处理</li></ul><p>建议将所有与生命周期相关的逻辑收敛到服务提供者中，而不是零散地分布在应用各处，这样更便于维护和测试。</p>`,27)])])}const E=a(t,[["render",n]]);export{c as __pageData,E as default};
