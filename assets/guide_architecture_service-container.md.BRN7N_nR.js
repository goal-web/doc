import{_ as i,c as a,o as t,ae as e}from"./chunks/framework.DYx9Zc8T.js";const E=JSON.parse('{"title":"服务容器","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture/service-container.md","filePath":"guide/architecture/service-container.md"}'),h={name:"guide/architecture/service-container.md"};function l(n,s,p,k,r,d){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="服务容器" tabindex="-1">服务容器 <a class="header-anchor" href="#服务容器" aria-label="Permalink to &quot;服务容器&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>服务容器是 Goal-Web 的核心组件之一，负责管理应用中的所有依赖关系：</p><ul><li>统一创建和管理对象实例</li><li>支持按需解析（Lazy Resolve）</li><li>支持单例、普通绑定和已有实例注册</li><li>支持别名与类型自动解析</li></ul><p>你可以把服务容器看作是一个强类型的依赖注入容器，它让你的业务代码更关注 &quot;要什么&quot;，而不是 &quot;怎么构造&quot;。</p><h2 id="容器实现" tabindex="-1">容器实现 <a class="header-anchor" href="#容器实现" aria-label="Permalink to &quot;容器实现&quot;">​</a></h2><p>容器的具体实现位于 <code>container</code> 包中，其核心结构大致如下：</p><ul><li><code>binds</code>：普通绑定（每次解析都会创建新的实例）</li><li><code>singletons</code>：单例绑定（第一次解析时创建实例并缓存）</li><li><code>instances</code>：已存在的实例（直接返回，不再创建）</li><li><code>aliases</code>：别名映射，用于支持多种 key 访问同一服务</li></ul><p>通过这些结构，容器可以灵活地管理各种服务和对象。</p><h2 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h2><h3 id="创建容器" tabindex="-1">创建容器 <a class="header-anchor" href="#创建容器" aria-label="Permalink to &quot;创建容器&quot;">​</a></h3><p>在应用内部，<code>Application</code> 自身就是一个容器实现；如果你需要单独使用容器，也可以直接创建：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="绑定服务" tabindex="-1">绑定服务 <a class="header-anchor" href="#绑定服务" aria-label="Permalink to &quot;绑定服务&quot;">​</a></h3><p>绑定服务有三种常见方式：</p><h4 id="普通绑定" tabindex="-1">普通绑定 <a class="header-anchor" href="#普通绑定" aria-label="Permalink to &quot;普通绑定&quot;">​</a></h4><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;redis&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Redis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>每次通过 <code>app.Get(&quot;redis&quot;)</code> 解析时，都会调用一次函数，返回一个新的实例。</p><h4 id="单例绑定" tabindex="-1">单例绑定 <a class="header-anchor" href="#单例绑定" aria-label="Permalink to &quot;单例绑定&quot;">​</a></h4><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;db&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> database.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>容器会在第一次解析时创建实例并缓存，以后每次都返回同一个实例。</p><h4 id="直接注册实例" tabindex="-1">直接注册实例 <a class="header-anchor" href="#直接注册实例" aria-label="Permalink to &quot;直接注册实例&quot;">​</a></h4><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> logs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Instance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;logger&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, logger)</span></span></code></pre></div><p>这种方式适合那些已经创建好的对象。</p><h2 id="解析依赖" tabindex="-1">解析依赖 <a class="header-anchor" href="#解析依赖" aria-label="Permalink to &quot;解析依赖&quot;">​</a></h2><h3 id="手动解析" tabindex="-1">手动解析 <a class="header-anchor" href="#手动解析" aria-label="Permalink to &quot;手动解析&quot;">​</a></h3><p>最直接的方式是调用 <code>Get</code>：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;db&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>容器会根据 key 查找绑定、单例或实例并返回。</p><h3 id="自动注入" tabindex="-1">自动注入 <a class="header-anchor" href="#自动注入" aria-label="Permalink to &quot;自动注入&quot;">​</a></h3><p>容器不仅可以按 key 获取，还可以根据函数签名自动注入参数：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> NewUserRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">db</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">logger</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contracts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Logger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{db: db, logger: logger}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">repoAny </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(NewUserRepository)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">repo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repoAny.(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UserRepository</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>容器会根据参数类型，从已注册的服务中自动匹配合适的实例。</p><p>这种自动注入能力在控制器、服务对象、命令等场景中非常常见，也大大减少了手动拼装依赖的工作量。</p><h2 id="别名与类型解析" tabindex="-1">别名与类型解析 <a class="header-anchor" href="#别名与类型解析" aria-label="Permalink to &quot;别名与类型解析&quot;">​</a></h2><p>容器内部会为每个绑定生成一个基于类型的 key，并将你传入的字符串 key 映射为别名：</p><ul><li>你可以通过字符串 key（如 <code>&quot;db&quot;</code>）访问服务</li><li>也可以通过类型 key 在某些高级场景下进行解析</li></ul><p>这使得容器既保持了使用上的直观性，又保留了类型级别的精确控制。</p><h2 id="在框架中的位置" tabindex="-1">在框架中的位置 <a class="header-anchor" href="#在框架中的位置" aria-label="Permalink to &quot;在框架中的位置&quot;">​</a></h2><p>在 Goal-Web 中，服务容器贯穿几乎所有模块：</p><ul><li>控制器依赖注入</li><li>中间件依赖注入</li><li>命令行任务依赖注入</li><li>服务提供者注册与解析</li></ul><p>掌握容器的用法，是深入理解 Goal-Web 核心架构的第一步。</p>`,42)])])}const g=i(h,[["render",l]]);export{E as __pageData,g as default};
