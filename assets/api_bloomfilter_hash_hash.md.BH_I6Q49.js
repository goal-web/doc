import{_ as a,c as t,o as s,ae as h}from"./chunks/framework.DYx9Zc8T.js";const p=JSON.parse('{"title":"Package hash","description":"","frontmatter":{},"headers":[],"relativePath":"api/bloomfilter_hash_hash.md","filePath":"api/bloomfilter_hash_hash.md"}'),i={name:"api/bloomfilter_hash_hash.md"};function r(o,e,n,l,u,c){return s(),t("div",null,[...e[0]||(e[0]=[h(`<h1 id="package-hash" tabindex="-1">Package hash <a class="header-anchor" href="#package-hash" aria-label="Permalink to &quot;Package hash&quot;">​</a></h1><h2 id="types" tabindex="-1">Types <a class="header-anchor" href="#types" aria-label="Permalink to &quot;Types&quot;">​</a></h2><h3 id="type-digest128" tabindex="-1">type Digest128 <a class="header-anchor" href="#type-digest128" aria-label="Permalink to &quot;type Digest128&quot;">​</a></h3><p>Digest128 represents a partial evaluation of a 128 bites hash.</p><h4 id="func-digest128-sum128" tabindex="-1">func (Digest128) Sum128 <a class="header-anchor" href="#func-digest128-sum128" aria-label="Permalink to &quot;func (Digest128) Sum128&quot;">​</a></h4><p>sum128 computers two 64-bit hash value. It is assumed that bmix was first called on the data to process complete blocks of 16 bytes. The &#39;tail&#39; is a slice representing the &#39;tail&#39; (leftover elements, fewer than 16). If pad_tail is true, we make it seem like there is an extra element with value 1 appended to the tail. The length parameter represents the full length of the data (including the blocks of 16 bytes, and, if pad_tail is true, an extra byte).</p><h4 id="func-digest128-sum256" tabindex="-1">func (Digest128) Sum256 <a class="header-anchor" href="#func-digest128-sum256" aria-label="Permalink to &quot;func (Digest128) Sum256&quot;">​</a></h4><p>sum256 will compute 4 64-bit hash values from the input. It is designed to never allocate memory on the heap. So it works without any byte buffer whatsoever. It is designed to be strictly equivalent to</p><pre><code>			a1 := []byte{1}
         hasher := murmur3.New128()
         hasher.Write(data) // #nosec
         v1, v2 := hasher.Sum128()
         hasher.Write(a1) // #nosec
         v3, v4 := hasher.Sum128()
</code></pre><p>See TestHashRandom.</p>`,10)])])}const m=a(i,[["render",r]]);export{p as __pageData,m as default};
